<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Anime Object Detector — Mobile First (Front/Back + Confidence)</title>
  <style>
    /* Mobile-first modern clean anime-ish (no neon) */
    :root{--bg:#f6f8ff;--card:#ffffff;--accent:#6c8efc;--muted:#6b7280}
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;background:var(--bg);color:#111}

    header{position:sticky;top:0;background:linear-gradient(180deg,rgba(255,255,255,0.95),rgba(255,255,255,0.85));backdrop-filter:blur(6px);padding:12px 14px;border-bottom:1px solid rgba(16,24,40,0.04);z-index:40}
    header h1{margin:0;font-size:16px;font-weight:700}
    header p{margin:4px 0 0;font-size:13px;color:var(--muted)}

    main{padding:12px;display:flex;flex-direction:column;gap:12px}
    .card{background:var(--card);border-radius:12px;padding:12px;box-shadow:0 6px 18px rgba(16,24,40,0.06)}

    /* video area */
    .video-outer{position:relative;width:100%;overflow:hidden;border-radius:10px;background:#000}
    video#webcam{width:100%;height:auto;display:block;object-fit:cover}
    canvas#overlay{position:absolute;left:0;top:0;pointer-events:none}

    /* controls */
    .controls{display:flex;gap:8px;align-items:center}
    .primary{background:var(--accent);color:#fff;border:0;padding:10px 12px;border-radius:10px;font-weight:600}
    .muted-btn{background:transparent;border:1px solid rgba(16,24,40,0.06);padding:8px 10px;border-radius:10px}
    .flex{display:flex;align-items:center;gap:8px}

    .row{display:flex;justify-content:space-between;align-items:center}
    .small{font-size:13px;color:var(--muted)}

    /* detection list */
    #detectedList{display:flex;flex-direction:column;gap:8px;margin-top:8px}
    .det-item{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:8px;background:linear-gradient(180deg,rgba(0,0,0,0.02),transparent)}
    .det-item .label{font-weight:700}
    .det-meta{font-size:13px;color:var(--muted)}

    /* layout for larger screens */
    @media(min-width:900px){
      main{flex-direction:row}
      .left{flex:2}
      .right{flex:1;max-height:84vh;overflow:auto}
    }

    /* make overlays text crisp on mobile */
    canvas{image-rendering:pixelated}
  </style>
</head>
<body>
  <header>
    <h1>Object Detector (Mobile‑first)</h1>
    <p>Front / Back camera toggle · Confidence score · Works on phone browsers (HTTPS or localhost)</p>
  </header>

  <main>
    <section class="left">
      <div class="card video-card">
        <div class="video-outer" id="videoOuter">
          <video id="webcam" autoplay playsinline muted></video>
          <canvas id="overlay"></canvas>
        </div>

        <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap;align-items:center">
          <button id="startBtn" class="primary">Start Camera</button>
          <button id="stopBtn" class="muted-btn">Stop</button>
          <button id="switchBtn" class="muted-btn">Use Front Camera</button>

          <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
            <label class="small">Min Confidence <span id="confVal">50%</span></label>
            <input id="minConf" type="range" min="0" max="100" value="50" style="width:120px">
          </div>
        </div>

        <div style="display:flex;gap:12px;margin-top:10px;align-items:center">
          <div class="small">Status: <span id="status">Idle</span></div>
          <div class="small">FPS: <span id="fps">--</span></div>
          <div style="margin-left:auto" class="small">Labels: <input id="showLabels" type="checkbox" checked></div>
        </div>

        <div id="errorArea" style="display:none;margin-top:10px" class="card" aria-live="polite"></div>
      </div>

      <div class="card" style="margin-top:12px">
        <div style="font-weight:700">How to use</div>
        <div class="small" style="margin-top:6px">• Open on https:// or on <code>localhost</code> on your phone. Allow camera when prompted. Use the switch button to toggle front/back camera. Adjust Min Confidence to filter detections.</div>
      </div>
    </section>

    <aside class="right card">
      <div style="font-weight:700">Detected Objects</div>
      <div id="detectedList"></div>
    </aside>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.20.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>
  <script>
    // Elements
    const video = document.getElementById('webcam');
    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const switchBtn = document.getElementById('switchBtn');
    const statusEl = document.getElementById('status');
    const errorArea = document.getElementById('errorArea');
    const detectedList = document.getElementById('detectedList');
    const fpsEl = document.getElementById('fps');
    const minConf = document.getElementById('minConf');
    const confVal = document.getElementById('confVal');
    const showLabels = document.getElementById('showLabels');

    let model = null;
    let stream = null;
    let running = false;
    let useFront = false; // false = back (environment), true = front (user)
    let lastDetected = new Map();

    // fps
    let frames = 0; let lastFps = performance.now();

    confVal.textContent = minConf.value + '%';
    minConf.addEventListener('input', ()=> confVal.textContent = minConf.value + '%');

    function showError(msg){ errorArea.style.display='block'; errorArea.textContent = msg; statusEl.textContent = 'Error'; }
    function clearError(){ errorArea.style.display='none'; errorArea.textContent = ''; }

    function isSecure(){ const h = location.hostname; if(h==='localhost' || h==='127.0.0.1') return true; return location.protocol === 'https:'; }

    async function ensureModel(){ if(model) return model; statusEl.textContent='Loading model...'; model = await cocoSsd.load(); statusEl.textContent='Model loaded'; return model; }

    async function startCamera(){
      clearError();
      if(running) return;
      if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){ showError('getUserMedia not supported in this browser.'); return; }
      if(!isSecure()){ showError('Page must be served over HTTPS or localhost for camera access.'); return; }

      const facingMode = useFront ? 'user' : 'environment';
      const constraints = { video: { facingMode, width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false };

      try{
        statusEl.textContent = 'Requesting camera...';
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        // Attach stream
        video.srcObject = stream;
        await video.play();
        resizeCanvas();
        await ensureModel();
        running = true;
        statusEl.textContent = 'Detecting...';
        requestAnimationFrame(detectLoop);
      }catch(err){
        console.error('Camera error', err);
        handleGetUserMediaError(err);
      }
    }

    function stopCamera(){
      running = false;
      if(stream){ stream.getTracks().forEach(t=>t.stop()); stream = null; }
      ctx.clearRect(0,0,overlay.width,overlay.height);
      statusEl.textContent = 'Stopped';
      lastDetected.clear();
      detectedList.innerHTML = '';
      clearError();
    }

    async function switchCamera(){
      useFront = !useFront;
      switchBtn.textContent = useFront ? 'Use Back Camera' : 'Use Front Camera';
      // restart camera if running
      if(stream){ stopCamera(); await startCamera(); }
    }

    function handleGetUserMediaError(err){
      if(err && err.name === 'NotAllowedError'){
        showError('Permission denied — allow camera in site settings (address bar / lock icon).');
      } else if(err && err.name === 'NotFoundError'){
        showError('No camera found. Connect a camera or try another device.');
      } else if(err && err.name === 'NotReadableError'){
        showError('Camera already in use. Close other apps and retry.');
      } else {
        showError(err && err.message ? err.message : 'Unknown camera error');
      }
    }

    function resizeCanvas(){
      const w = video.videoWidth || video.clientWidth || 640;
      const h = video.videoHeight || video.clientHeight || 480;
      overlay.width = w;
      overlay.height = h;
      overlay.style.width = (video.clientWidth || '100%') + 'px';
      overlay.style.height = (video.clientHeight || '100%') + 'px';
    }

    async function detectLoop(){
      if(!running) return;
      if(video.readyState < 2){ requestAnimationFrame(detectLoop); return; }

      try{
        const predictions = await model.detect(video);
        drawPredictions(predictions);
      }catch(e){ console.error('detect error', e); }

      // fps
      frames++;
      const now = performance.now();
      if(now - lastFps > 500){ fpsEl.textContent = Math.round((frames*1000)/(now-lastFps)) + ' FPS'; frames = 0; lastFps = now; }
      requestAnimationFrame(detectLoop);
    }

    function drawPredictions(predictions){
      resizeCanvas();
      ctx.clearRect(0,0,overlay.width,overlay.height);
      const minScore = parseFloat(minConf.value)/100;
      const seen = new Map();

      predictions.forEach(p => {
        if(!p || typeof p.score !== 'number') return;
        if(p.score < minScore) return;
        const [x,y,w,h] = p.bbox;
        // draw box
        ctx.lineWidth = Math.max(2, Math.floor(overlay.width/300));
        ctx.strokeStyle = '#2b6cb0';
        ctx.strokeRect(x,y,w,h);
        if(showLabels.checked){
          const txt = `${p.class} ${Math.round(p.score*100)}%`;
          ctx.font = `${Math.max(12, Math.floor(overlay.width/60))}px sans-serif`;
          const pad = 6;
          const textW = ctx.measureText(txt).width + pad*2;
          // background
          ctx.fillStyle = 'rgba(255,255,255,0.9)';
          roundRect(ctx, x, Math.max(0,y - 24), textW, 20, 6, true, false);
          // text
          ctx.fillStyle = '#06202a';
          ctx.fillText(txt, x + pad, Math.max(0,y - 10));
        }

        // aggregate for list: use highest confidence
        const prev = seen.get(p.class);
        if(!prev || p.score > prev.score) seen.set(p.class, {score:p.score, bbox:p.bbox});
      });

      updateDetectedList(seen);
    }

    function updateDetectedList(seenMap){
      // age and remove
      for(const key of Array.from(lastDetected.keys())){
        const obj = lastDetected.get(key); obj.age = (obj.age||0) + 1; if(obj.age > 40) lastDetected.delete(key);
      }
      // update with seen
      for(const [cls,meta] of seenMap){
        if(!lastDetected.has(cls)) lastDetected.set(cls, {count:1,score:meta.score,age:0});
        else { const o = lastDetected.get(cls); o.count = (o.count||0)+1; o.score = Math.max(o.score||0, meta.score); o.age = 0; lastDetected.set(cls,o); }
      }

      // render
      detectedList.innerHTML = '';
      for(const [cls,meta] of Array.from(lastDetected.entries()).sort((a,b)=>b[1].count-a[1].count)){
        const div = document.createElement('div'); div.className = 'det-item';
        div.innerHTML = `<div><div class="label">${cls}</div><div class="det-meta">${Math.round((meta.score||0)*100)}% • seen ${meta.count}x</div></div><div style="font-weight:700">${Math.round((meta.score||0)*100)}%</div>`;
        detectedList.appendChild(div);
      }
    }

    // utility: rounded rect
    function roundRect(ctx,x,y,w,h,r,fill,stroke){ if(typeof r==='undefined') r=6; ctx.beginPath(); ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r); ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h); ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r); ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y); ctx.closePath(); if(fill) ctx.fill(); if(stroke) ctx.stroke(); }

    // Wire up controls
    startBtn.addEventListener('click', startCamera);
    stopBtn.addEventListener('click', stopCamera);
    switchBtn.addEventListener('click', switchCamera);

    // Initial UI state
    switchBtn.textContent = 'Use Front Camera';

    // Permissions info on load
    (function init(){
      if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){ showError('getUserMedia not available in this browser. Use a modern browser (Chrome/Edge/Firefox).'); }
      if(!isSecure() && location.hostname!=='localhost' && location.hostname!=='127.0.0.1'){
        showError('Serve this page over HTTPS or use localhost for camera access.');
      }
    })();

    // Clean up on unload
    window.addEventListener('pagehide', ()=>{ stopCamera(); });
  </script>
</body>
</html>
